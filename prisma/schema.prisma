generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  userId          String     @id @default(uuid()) // Changed to uuid
  email           String     @unique
  password        String?
  name            String?
  userStatus      UserStatus @default(ACTIVE)
  isEmailVerified Boolean    @default(false)

  role   Role?   @relation(fields: [roleId], references: [roleId])
  roleId String?

  store Store?

  verificationTokens VerificationToken[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  id        String       @id @default(uuid())
  userId    String
  user      User         @relation(fields: [userId], references: [userId], onDelete: Cascade)
  token     String       @unique
  purpose   TokenPurpose
  expiresAt DateTime
  used      Boolean      @default(false)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
}

model Role {
  roleId      String   @id @default(uuid())
  name        RoleName @unique
  description String?

  // Relations
  employees Employee[]
  users     User[]
  customers Customer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Customer {
  id   String  @id @default(uuid())
  name String?

  lineUserId    String  @unique
  displayName   String?
  pictureUrl    String?
  statusMessage String?
  isLineLinked  Boolean @default(true)

  phone String?
  email String?

  booking Booking[]

  role   Role?   @relation(fields: [roleId], references: [roleId])
  roleId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Booking {
  id String @id @default(uuid())

  customerName  String
  customerPhone String
  customerEmail String?

  bookingDate DateTime
  bookingTime DateTime

  status       BookingStatus @default(CONFIRMED)
  customerType CustomerType  @default(LINE)

  storeId String
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  serviceId String
  service   Service @relation(fields: [serviceId], references: [id])

  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id])

  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Service {
  id              String  @id @default(uuid())
  name            String
  durationMinutes Int     @default(0)
  price           Float   @default(0)
  discount        Float   @default(0)
  bufferTime      Int     @default(0)
  detail          String?
  displayNumber   Int?
  imageId         String?
  imageUrl        String?
  colorOfService  String?
  active          Boolean @default(true)
  isDelete        Boolean @default(false)

  storeId String
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  // Many-to-Many in Postgres requires an implicit or explicit join table
  employees Employee[]

  bookings Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Employee {
  id       String  @id @default(uuid())
  name     String
  surname  String
  nickname String?
  email    String
  password String
  phone    String?
  note     String?

  isActive Boolean @default(true)
  isDelete Boolean @default(false)

  imageId   String?
  imageUrl  String?
  position  String?
  startDate DateTime?

  storeId String
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  bookings Booking[]
  services Service[] // Implicit many-to-many join table created by Prisma

  roleId String?
  role   Role?   @relation(fields: [roleId], references: [roleId])

  workingDays EmployeeWorkingDay[]
  leaves      EmployeeLeave[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EmployeeWorkingDay {
  id         String @id @default(uuid())
  employeeId String

  dayOfWeek DayOfWeek
  isWorking Boolean   @default(false)

  timeSlots EmployeeWorkingTime[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  employee  Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([employeeId, dayOfWeek])
}

model EmployeeWorkingTime {
  id           String @id @default(uuid())
  workingDayId String

  startTime String
  endTime   String

  workingDay EmployeeWorkingDay @relation(fields: [workingDayId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
}

model EmployeeLeave {
  id         String @id @default(uuid())
  employeeId String

  startDate DateTime
  endDate   DateTime

  leaveType LeaveType
  note      String?

  createdAt DateTime @default(now())
  employee  Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
}

model DefaultOperatingHour {
  id String @id @default(uuid())

  MON_isOpen    Boolean   @default(false)
  MON_openTime  DateTime?
  MON_closeTime DateTime?

  TUE_isOpen    Boolean   @default(false)
  TUE_openTime  DateTime?
  TUE_closeTime DateTime?

  WED_isOpen    Boolean   @default(false)
  WED_openTime  DateTime?
  WED_closeTime DateTime?

  THU_isOpen    Boolean   @default(false)
  THU_openTime  DateTime?
  THU_closeTime DateTime?

  FRI_isOpen    Boolean   @default(false)
  FRI_openTime  DateTime?
  FRI_closeTime DateTime?

  SAT_isOpen    Boolean   @default(false)
  SAT_openTime  DateTime?
  SAT_closeTime DateTime?

  SUN_isOpen    Boolean   @default(false)
  SUN_openTime  DateTime?
  SUN_closeTime DateTime?

  storeId String @unique
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("defaultOperatingHours")
}

model Holiday {
  id String @id @default(uuid())

  date        DateTime
  startTime   DateTime?
  fullDay     Boolean     @default(true)
  endTime     DateTime?
  holidayName String
  holidayType HolidayType @default(ANNUAL)

  storeId String
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Store {
  id            String @id @default(uuid())
  storeName     String
  storeUsername String @unique
  lineOALink    String

  latitude  Float?
  longitude Float?
  address   String?
  placeId   String?

  storeNameTH   String?
  tel           String?
  addressCustom String?
  mapUrl        String?
  detail        String?

  logoUrl  String?
  logoId   String?
  coverUrl String?
  coverId  String?

  lineNotifyToken   String?
  lineChannelId     String?
  lineChannelSecret String?

  newBooking     String?
  successBooking String?
  cancelBooking  String?
  before24H      String?
  reSchedule     String?

  isDelete Boolean @default(false)

  // Postgres uses Json for composite objects
  employeeSetting Json
  bookingRule     Json
  cancelRule      Json

  userId String @unique
  user   User   @relation(fields: [userId], references: [userId], onDelete: Cascade)

  employees      Employee[]
  services       Service[]
  bookings       Booking[]
  operatingHours DefaultOperatingHour?
  notifications  Notification[]
  holiday        Holiday[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Notification {
  id String @id @default(uuid())

  type          NotificationType
  method        SendMethod
  message       String
  targetAddress String

  isSent       Boolean   @default(false)
  sentAt       DateTime?
  errorMessage String?

  storeId String
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  lineUserId String?
}

// Enums remain the same
enum UserStatus {
  ACTIVE
  INACTIVE
}

enum TokenPurpose {
  EMAIL_VERIFICATION
  PASSWORD_RESET
}

enum RoleName {
  ADMIN
  STOREADMIN
  CUSTOMER
}

enum BookingStatus {
  PENDING
  CONFIRMED
  RESCHEDULED
  CANCELLED
  COMPLETED
}

enum HolidayType {
  ANNUAL
  SPECIAL
}

enum NotificationType {
  STORE_NEW_BOOKING
  STORE_CANCELED_BY_CUSTOMER
  STORE_BOOKING_MODIFIED
  CUSTOMER_BOOKING_SUCCESS
  CUSTOMER_CONFIRMED
  CUSTOMER_RESCHEDULED
  CUSTOMER_CANCELED
}

enum CustomerType {
  LINE
  WALK_IN
  OTHER_CONTACT
}

enum SendMethod {
  LINE_NOTIFY
  LINE_MESSAGING_API
  EMAIL
}

enum DayOfWeek {
  MON
  TUE
  WED
  THU
  FRI
  SAT
  SUN
}

enum LeaveType {
  SICK
  VACATION
  PERSONAL
  OTHER
}
